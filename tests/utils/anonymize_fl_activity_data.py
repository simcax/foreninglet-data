"""
Anonymize VCR activity data files for testing
"""

import json
import random
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import yaml
from faker import Faker


def anonymize_vcr_file(
    input_file_path: Path, output_file_path: Optional[Path] = None
) -> bool:
    """
    Anonymizes a VCR cassette file containing ForeningLet API data.

    Args:
        input_file_path: Path to the input VCR YAML file
        output_file_path: Path for the output file. If None, adds '_anon' suffix to input filename

    Returns:
        bool: True if successful, False otherwise
    """

    if not input_file_path.exists():
        raise OSError(f"Input file does not exist: {input_file_path}")

    # Load the VCR YAML file
    try:
        with open(input_file_path, "r", encoding="utf-8") as file:
            vcr_data = yaml.safe_load(file)
    except Exception as e:
        print(f"Error loading YAML file: {e}")
        return False

    # Process each interaction in the VCR file
    if "interactions" in vcr_data:
        for interaction in vcr_data["interactions"]:
            # Anonymize request data
            if "request" in interaction:
                interaction["request"] = anonymize_request(interaction["request"])

            # Anonymize response data
            if "response" in interaction:
                interaction["response"] = anonymize_response(interaction["response"])

    # Determine output file path
    if output_file_path is None:
        output_file_path = (
            input_file_path.parent
            / f"{input_file_path.stem}_anon{input_file_path.suffix}"
        )

    # Write anonymized data to output file
    try:
        with open(output_file_path, "w", encoding="utf-8") as outfile:
            # Add comment to indicate this is anonymized data
            outfile.write(
                "# Anonymized test data - generated by anonymize_fl_activity_data.py\n"
            )
            yaml.dump(vcr_data, outfile, default_flow_style=False, allow_unicode=True)

        print(f"Successfully anonymized data written to: {output_file_path}")
        return True

    except Exception as e:
        print(f"Error writing output file: {e}")
        return False


def anonymize_request(request_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Anonymizes request data in VCR interaction.

    Args:
        request_data: The request portion of a VCR interaction

    Returns:
        Dict with anonymized request data
    """
    anonymized = request_data.copy()

    # Anonymize authorization headers
    if "headers" in anonymized:
        headers = anonymized["headers"]
        if "authorization" in headers:
            headers["authorization"] = ["DUMMY"]
        if "Authorization" in headers:
            headers["Authorization"] = ["DUMMY"]

    # Anonymize sensitive data in URI parameters
    if "uri" in anonymized:
        uri = anonymized["uri"]
        # Replace any potential API keys or tokens in query parameters
        uri = re.sub(r"([&?])(api_key|token|key)=([^&]*)", r"\1\2=DUMMY", uri)
        anonymized["uri"] = uri

    return anonymized


def anonymize_response(response_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Anonymizes response data in VCR interaction.

    Args:
        response_data: The response portion of a VCR interaction

    Returns:
        Dict with anonymized response data
    """
    anonymized = response_data.copy()

    # Anonymize response headers
    if "headers" in anonymized:
        headers = anonymized["headers"]
        # Anonymize session cookies
        if "Set-Cookie" in headers:
            headers["Set-Cookie"] = [
                re.sub(
                    r"cisession=([^;]*)",
                    r"cisession=99eed5491e2c47cda3a8f702151b9247",
                    cookie,
                )
                for cookie in headers["Set-Cookie"]
            ]

    # Anonymize response body
    if "body" in anonymized and "string" in anonymized["body"]:
        try:
            # Try to parse as JSON first (most common case)
            body_string = anonymized["body"]["string"]
            if body_string.strip().startswith("[") or body_string.strip().startswith(
                "{"
            ):
                activities_data = json.loads(body_string)
                anonymized_activities = anonymize_activities_data(activities_data)
                anonymized["body"]["string"] = json.dumps(anonymized_activities)
            else:
                # Handle other response types (HTML, plain text, etc.)
                anonymized["body"]["string"] = anonymize_text_content(body_string)

        except json.JSONDecodeError:
            # If not JSON, treat as plain text and anonymize
            anonymized["body"]["string"] = anonymize_text_content(
                anonymized["body"]["string"]
            )

    return anonymized


def anonymize_activities_data(activities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Anonymizes activity data from ForeningLet API responses.

    Args:
        activities: List of activity dictionaries from API response

    Returns:
        List of anonymized activity dictionaries
    """
    fake = Faker("da_DK")

    anonymized_activities = []

    for activity in activities:
        anonymized_activity = activity.copy()

        # Generate consistent fake data for this activity
        random.seed(hash(str(activity.get("ActivityId", ""))))
        fake.seed_instance(hash(str(activity.get("ActivityId", ""))))

        # Anonymize activity names while keeping some realistic structure
        if "Name" in anonymized_activity:
            original_name = anonymized_activity["Name"]
            anonymized_activity["Name"] = generate_fake_activity_name(
                original_name, fake
            )

        # Anonymize external descriptions
        if "ExternalDescriptions" in anonymized_activity:
            anonymized_activity["ExternalDescriptions"] = (
                anonymize_external_descriptions(
                    anonymized_activity["ExternalDescriptions"], fake
                )
            )

        # Keep structural data but anonymize department IDs to generic values
        if "DepartmentId" in anonymized_activity:
            # Map to a limited set of fake department IDs
            dept_id = anonymized_activity["DepartmentId"]
            anonymized_activity["DepartmentId"] = str(6205 + (hash(dept_id) % 10))

        anonymized_activities.append(anonymized_activity)

    return anonymized_activities


def generate_fake_activity_name(original_name: str, fake: Faker) -> str:
    """
    Generates a fake activity name based on the pattern of the original.

    Args:
        original_name: The original activity name
        fake: Faker instance for generating fake data

    Returns:
        A fake activity name
    """
    # Common activity types in Danish
    membership_types = [
        "Halvårs medlemsskab",
        "Helårs medlemsskab",
        "3 måneders medlemsskab",
        "Månedsmedlemsskab",
        "Ungdoms medlemsskab",
        "Senior medlemsskab",
    ]

    roles = [
        "Bestyrelse",
        "Instruktør",
        "Rengøringspersonale",
        "Kasserer",
        "Formand",
        "Næstformand",
        "Sekretær",
    ]

    special_memberships = [
        "Husstandsmedlemskab",
        "Familiemedlemskab",
        "Støttemedlemskab",
        "Æresmedlemskab",
        "Livsvarigt medlemskab",
    ]

    activities = [
        "Yoga",
        "Pilates",
        "Aerobic",
        "Zumba",
        "Styrketræning",
        "Løbeklub",
        "Svømning",
        "Badminton",
        "Tennis",
        "Fodbold",
        "Håndbold",
        "Volleyball",
        "Dans",
        "Meditation",
        "Spinning",
        "Crossfit",
    ]

    # Determine category based on original name patterns
    original_lower = original_name.lower()

    # Check for status indicators and preserve them
    status_indicators = []
    if "aflyst" in original_lower or "cancelled" in original_lower:
        status_indicators.append("AFLYST")
    if "udgået" in original_lower or "expired" in original_lower:
        status_indicators.append("UDGÅET")

    # Generate base name
    if any(word in original_lower for word in ["medlemsskab", "medlem"]):
        if any(word in original_lower for word in ["halvår", "halv", "6"]):
            base_name = "Halvårs medlemsskab"
        elif any(word in original_lower for word in ["helår", "hel", "år", "12"]):
            base_name = "Helårs medlemsskab"
        elif any(word in original_lower for word in ["3", "tre", "måned"]):
            base_name = "3 måneders medlemsskab"
        elif "husstand" in original_lower:
            base_name = "Husstandsmeldemskab"  # Keep the typo if it existed
        else:
            base_name = fake.random_element(membership_types)

    elif any(
        word in original_lower for word in ["bestyrelse", "instruktør", "rengøring"]
    ):
        base_name = fake.random_element(roles)

    elif any(
        word in original_lower
        for word in ["yoga", "pilates", "træning", "dans", "sport"]
    ):
        base_name = fake.random_element(activities)

    else:
        base_name = fake.random_element(special_memberships)

    # Add status indicators back
    if status_indicators:
        for status in status_indicators:
            base_name = f"{status} - {base_name}"

    return base_name


def anonymize_external_descriptions(
    descriptions: List[Dict[str, Any]], fake: Faker
) -> List[Dict[str, Any]]:
    """
    Anonymizes external descriptions while maintaining structure.

    Args:
        descriptions: List of description dictionaries
        fake: Faker instance for generating fake data

    Returns:
        List of anonymized description dictionaries
    """
    anonymized_descriptions = []

    for desc in descriptions:
        anonymized_desc = desc.copy()

        # Keep headlines but anonymize text content
        if "Headline" in anonymized_desc and "Text" in anonymized_desc:
            headline = anonymized_desc["Headline"]

            if headline == "Pris":
                # Keep price structure but use fake amounts
                price_match = re.search(r"[\d.,]+", anonymized_desc["Text"])
                if price_match:
                    fake_price = f"{fake.random_int(min=100, max=2000)},00"
                    anonymized_desc["Text"] = re.sub(
                        r"[\d.,]+", fake_price, anonymized_desc["Text"]
                    )

            elif headline == "Alder":
                # Keep age structure but use fake ranges
                min_age = fake.random_int(min=10, max=20)
                max_age = fake.random_int(min=60, max=130)
                birth_year_start = 2024 - max_age
                birth_year_end = 2024 - min_age
                anonymized_desc["Text"] = (
                    f"{min_age}-{max_age} år (fødselsår {birth_year_start}-{birth_year_end})"
                )

            elif headline == "Instruktør" or "instruktør" in headline.lower():
                # Generate fake instructor name
                fake_name = fake.name()
                anonymized_desc["Text"] = f"{fake_name} (Instruktør)"

            elif headline in ["Sted", "Location"]:
                # Generate fake location
                locations = [
                    "Multisalen",
                    "Hal A",
                    "Hal B",
                    "Gymnastiksal",
                    "Mødelokale 1",
                    "Udeområdet",
                ]
                anonymized_desc["Text"] = fake.random_element(locations)

            elif headline in ["Tilmelding åbner", "Afviklingsdato", "Tilmeldingsfrist"]:
                # Keep date/time structure but use fake dates
                anonymized_desc["Text"] = anonymize_text_content(
                    anonymized_desc["Text"]
                )

            else:
                # For all other content, apply general text anonymization
                anonymized_desc["Text"] = anonymize_text_content(
                    anonymized_desc["Text"]
                )

        anonymized_descriptions.append(anonymized_desc)

    return anonymized_descriptions


def anonymize_text_content(text: str) -> str:
    """
    Anonymizes text content by replacing sensitive information.

    Args:
        text: The text to anonymize

    Returns:
        Anonymized text
    """
    fake = Faker("da_DK")

    # Replace email addresses
    text = re.sub(
        r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",
        "anonymized@example.com",
        text,
    )

    # Replace phone numbers
    text = re.sub(r"\+?45\s?[\d\s]{8,12}", "+45 XXXX XXXX", text)
    text = re.sub(r"\b\d{2}\s?\d{2}\s?\d{2}\s?\d{2}\b", "XX XX XX XX", text)

    # Replace Danish names (common patterns)
    danish_name_patterns = [
        r"\b[A-ZÆØÅ][a-zæøå]+\s+[A-ZÆØÅ][a-zæøå]+(?:\s+[A-ZÆØÅ][a-zæøå]+)?\b",  # Full names
        r"\b[A-ZÆØÅ][a-zæøå]+\s+[A-ZÆØÅ]\.\s+[A-ZÆØÅ][a-zæøå]+\b",  # Names with middle initial
    ]

    for pattern in danish_name_patterns:

        def replace_name(match):
            return fake.name()

        text = re.sub(pattern, replace_name, text)

    # Replace specific amounts in DKK
    text = re.sub(r"\b\d+,\d{2}\s?DKK\b", "XXX,XX DKK", text)

    # Replace specific kroner amounts
    text = re.sub(r"\b\d+\s?kr\.?\b", "XXX kr.", text)

    # Replace specific dates (Danish format)
    def replace_date(match):
        fake_date = fake.date_between(start_date="-1y", end_date="+1y")
        return fake_date.strftime("%d. %B %Y").lower()

    text = re.sub(r"\b\d{1,2}\. [a-zæøå]+ \d{4}\b", replace_date, text)

    # Replace specific times
    def replace_time(match):
        import random

        hours = random.randint(8, 20)
        minutes = random.choice([0, 15, 30, 45])
        return f"kl. {hours:02d}:{minutes:02d}"

    text = re.sub(r"\bkl\. \d{2}:\d{2}\b", replace_time, text)

    # Replace specific venue names that might be real
    venue_patterns = [
        r"\b[A-ZÆØÅ][a-zæøå]+hallen?\b",  # Hall names ending in 'hallen'
        r"\b[A-ZÆØÅ][a-zæøå]+salen?\b",  # Room names ending in 'salen'
    ]

    venues = ["Multisalen", "Gymnastiksal", "Hal A", "Hal B", "Mødelokale"]

    for pattern in venue_patterns:
        text = re.sub(pattern, lambda m: fake.random_element(venues), text)

    return text


def main():
    """Main CLI entry point"""
    import sys

    # Simple argument parsing
    if len(sys.argv) < 2:
        print(
            "Usage: python -m tests.utils.anonymize_fl_activity_data <input_file> [output_file]"
        )
        print(
            "       uv run python -m tests.utils.anonymize_fl_activity_data <input_file> [output_file]"
        )
        print("")
        print("Examples:")
        print(
            "  python -m tests.utils.anonymize_fl_activity_data tests/cassettes/test.yaml"
        )
        print(
            "  python -m tests.utils.anonymize_fl_activity_data tests/cassettes/test.yaml output.yaml"
        )
        sys.exit(1)

    if sys.argv[1] in ["--help", "-h"]:
        print("VCR Activity Data Anonymizer")
        print("")
        print("Anonymizes VCR cassette files containing ForeningLet API data")
        print("")
        print(
            "Usage: python -m tests.utils.anonymize_fl_activity_data <input_file> [output_file]"
        )
        print("")
        print("Arguments:")
        print("  input_file    Path to the VCR file to anonymize")
        print(
            "  output_file   Output file path (optional, defaults to input_file_anon.yaml)"
        )
        print("")
        print("Examples:")
        print(
            "  python -m tests.utils.anonymize_fl_activity_data tests/cassettes/test.yaml"
        )
        print(
            "  python -m tests.utils.anonymize_fl_activity_data tests/cassettes/test.yaml anonymized.yaml"
        )
        sys.exit(0)

    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None

    input_path = Path(input_file)
    output_path = Path(output_file) if output_file else None

    try:
        success = anonymize_vcr_file(input_path, output_path)
        if success:
            print("✅ File anonymized successfully!")
        else:
            print("❌ Failed to anonymize file")
            sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
